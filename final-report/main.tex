\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

%% Sets page size and margins
\usepackage[a4paper,top=2.5cm,bottom=2.5cm,left=2.5cm,right=2.5cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{subfigure}
\usepackage{caption}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{upquote}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{dirtytalk}
\usepackage{hyperref}
\usepackage{float}

\usepackage{xcolor}
\usepackage{indentfirst}

\linespread{1.1}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}
\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    language=C
}


\def\therefore{\boldsymbol{\text{ }
\leavevmode
\lower0.4ex\hbox{$\cdot$}
\kern-.5em\raise0.7ex\hbox{$\cdot$}
\kern-0.55em\lower0.4ex\hbox{$\cdot$}
\thinspace\text{ }}}

\title{A Journey to the Interactive 3D Fractal World}
\author{CSED Yang Junha 20160785, Ryu Sangwoo 20160845, Sung Haebin 20160463}

\begin{document}
\maketitle
\begin{abstract}
We researched and developed a program that presents interactive 3D fractal world in real time.
Our main idea is to seperate pixel-level fractal and polygonal fractal and combine them with texture.
To do this in an interactive way, the fractals should be rendered dynamically and efficiently.
We designed our own rendering pipeline and present some ideas to achieve interesting features of factal rendering.
And finally we've succeeded on implementing actual program with OpenGL.
\end{abstract}
\section{Motivation}
Fractals are so beautiful.


\section{Theoretical Backgrounds}
\subsection{Fractal}
A fractal is a recursive, infinitely self-reproductive geometric pattern. Fractals have similar patterns at smaller scales. So if we zoom into a fractal, we could experience a . A fractal is usually defined as a mathematical equation, or a recursive equation. There are some known techniques of generating a fractal; One could be Escape-time fractals, and another one could be Finite subdivision rules. We use each fractal of those categories in this project. Escape time fractals use a formula at each point in a space to determine the pattern. Finite subdivision rules use a recursive topoligical algorithm to define the pattern. We use the terms pixel level fractal for the escape time fractal, and 3D geometric polygonal fractal for the finite subdivision rule. 
\subsection{Mandelbrot Set}
The mandelbrot set is an example of escape time fractals. It is defined as whether a function diverges or not. It is useless to Mandelbrot set images may be created by sampling the complex numbers and testing, for each sample point c, whether the sequence goes to infinity. Images of the Mandelbrot set exhibit an elaborate and infinitely complicated boundary that reveals progressively ever-finer recursive detail at increasing magnifications.

\section{Task}
Again, we're goal is to implement a program that present real-time rendering of 3D fractal world with interaction.
There are some fractals which are pixel-level but also in 3D space.
One of example is `Mandelbulb', which is kind of generalization of Mandelbrot set onto 3D coordinates.
That kind of fractals of course can yield beautiful 3D fractal world, however very exepensive because it is basically voxel calculation.

Instead, we take our approach as `fractal on fractal'.
That means \textbf{Mandelbrot set, the pixel level fractal is textured on 3D geometric polygonal fractal}.
By doing this, we can get nice 3D fractal world with relatively reasonable cost.
To give impression of `wandering in the fractal world', the camera will stay \textit{inside} the geometric fractal, whereas the Mandelbrot set is covered on that.
There are many issues with doing this, and we solve them one by one with our own ideas. (will be explained in \ref{sec:2})
Our goal is to design well-structured rendering pipeline and to implement all required process into real executable program.


\section{Ideas and Implmentation}\label{sec:2}
\subsection{Development Enviornment and Codes}
We develop everything in C++ and OpenGL only.
As we mentioned in proposal, utilizing shaders directly is essential for what we do.
Thus we chose OpenGL for our development environment.

If you want to know about details about our codes,
we recommend you to read Assignment 2-4 report of Yang and Sung, because we adopt basic OpenGL structure from those.
Here are some notable source codes.
\begin{itemize}
  \item void CGraphics::M\_SimplePolyFractal(void) constructs hierarchy for fractal.
  \item void CGraphics::M\_RenderFractal(void) renders fractal.
  \item bool CGraphics::M\_MoveRequest(Vec3d d) takes movement info and expands. (see \ref{sssec:num1}.)
  \item `ver\_shd.glsl' and `frag\_test.glsl' are shaders for fractal.
\end{itemize}
\subsection{Rendering a Mandelbrot set}

\begin{lstlisting}[style=CStyle]
int main(void)
{
  printf("If you want to paste code here then do this way");
}
\end{lstlisting}
\subsection{3D Geometric Fractals}
\subsubsection{Meshes}
We have two basic meshs to implement geometric fractals.
One is sphere with 6 holes, another is wormhole to connect between spheres
Because we have to connect to meshes smoothly, we construct wormhole with splines covering sphere using Loft NURBS in MAXON Cinema 4D, and apply subdivision surface.
Mesh with one sphere and one wormhole is one node in hierachical structure, and basic unit of expansion.
\begin{figure}[H]
\centering
\subfigure[Sphere with 6 holes]
{
    \label{fig:subfig1}
    \includegraphics[scale=0.1]{sphere.png}
}
\subfigure[Wormhole]
{
    \label{fig:subfig1}
    \includegraphics[scale=0.1]{wormhole.png}
}
\caption[1]{Hierarchical model for fractal.}
\end{figure}

\subsubsection{Hiearchy}
Geometric fractals can be regarded as a special case of hierarchical model.
But, the hierarchical transfomrations are given \textit{recursively}, and each nodes have same rendering function.
If we give two recursive hierarchical transfomrations, then the fractal will grow double for each step, because the tree will be branched twice.
Then specify the maximum depth, and we can get a nice geometric fractal.
In this project, we construct the geometric fractal with 5 recursive transformation.
\begin{figure}[H]
\centering
\subfigure[5 direction of recursive transformations]
{
    \label{fig:subfig1}
    \includegraphics[scale=0.2]{hier.PNG}
}
\subfigure[Exapnded in maximum steps of 2]
{
    \label{fig:subfig1}
    \includegraphics[scale=0.2]{expand.PNG}
}
\caption[1]{Hierarchical model for fractal.}
\end{figure}

\subsubsection{Path Tracking}\label{sssec:num1}
To `wander' into the fractal world, that geometric fractal should be somewhat `surrounding' environment for viewer.
That means the camera will move \textit{inside} the fractal, and the should able to explore deeply.
This going-through must be availiable infinitely, and this is a problem.

If we simply expand fractal in more depth, the program will die soon. (remember that the nodes grow exponentially.)
Even 10 steps require $5^{10}=9,765,6254$ nodes in the scene.
Thus we should render only relevant nodes according to current position of camera.
The idea here is to keep track of recursion path of current node.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{tree.png}
\caption[q]{Recursive hierarchy tree. Note that the branches are reduced in 2 steps for simplicity.}
\label{fig:tree}
\end{figure}

If the program keep track of the path which the camera had moved along, then we know exactly where we are in big tree of hierarchy.
Then, the rendering pipeline can choose \textit{relevant} nodes to camera, and can partially render them.
For example, in figure \ref{fig:tree}, those nodes in the green line will be chosen to be rendered.

To track the path(or trace), we should check every single movement of camera.
If the camera goes outside of current node, then see the direction(one of 5) and push it on path stack.
\begin{enumerate}
  \item Accumulate all recursive transformation using the path.
  \item Get the transformation M.
  \item Take inverse of M and multiply on my position to take everything into node(model) space.
  \item Perform a collision detection for each 6 sides of node.
  \item Find out the branch of recursion and stack on my path.
\end{enumerate}

\begin{figure}[H]
\centering
\subfigure[Partial rendering by path tracking. Note that this viewing is from another camera, and real camera is now inside the polygon.]
{
    \label{fig:subfig1}
    \includegraphics[scale=0.5]{path1.PNG}
}
\subfigure[From another view.]
{
    \label{fig:subfig1}
    \includegraphics[scale=0.5]{path2.PNG}
}
\caption[1]{Path tracking is now on.}
\end{figure}

\subsection{Texture Mapping}
Now we have to combine those seemingly independent two fractals (Mandelbrot and geometric).
Again, our approach is `fractal on fractal' and key idea is take Mandelbrot set as a `texture' for the polygons, the geometric fractal.
The texture coordinate from polygon will be used as coordinate in Mandelbrot set,
Note that the program keep two camera, one for Mandelbrot set and one for 3D world(with geometric fractal).
Then it will be like that Mandelbrot set is traversed with some movement, while being projected on fractalistic polygons.

We tried to assign pre-determined texture coordinates on mesh itself,
but it was very difficult to match continuity between wormhole and sphere. (Remeber there are 8 holes and all should be synchronized)
Instead, we just dynamically assign texture coordinate via simple mathematical formulation.

For this, two things musd be considered very carefully.
\begin{itemize}
  \item Texture coordinates should be continuous everwhere.
  \item Mandelbrot set lies on limited space, somewhere around (-1, 1).
\end{itemize}

Keeping texture coordinate continous can be achieved by using vertices' world coordinate, because they are also continous in world.
Of course the 3D coordinates should be transformed into 2D one, so we combined them linearly.
And for the domain (-1, 1), we just take sin of cooridnates.

\begin{align*}
T_x&=sin(F(P_x+P_y))\\
T_y&=sin(F(P_y+P_z))
\end{align*}
Here $T$ is texture coordinate, $P$ is world coordinate, and $F$ is coefficient about fractal scale.
\subsection{Shading}
Shading is important for viewer to percept spatial structure even in non realistic fractal world.
It could be confusing to wander 6-sided chambers freely in 3D dimension.
So we applied basic shading (diffuse, specular ...) on polygons.
Assignment4 was helpful for this.

\subsection{Deformations}
We apply realtime deformation on geometric fractal, to get some interesting spatial effect.
We can easily impose some distortion on vertices in vertex shader, with time variable $t$ and sin.
The problem is keeping both C0 continuity and C1 continuity on the sphere and wormhole.
That's because we always put them together but they are separated meshes in program, for further flexible reconstruction of geometry.
C0 continuity is easy because it's not a problem if we can apply same transformation on joint.

C1 continuity, or smoothness is hard to achieve, so we just rather make `illusion' of smoothness.
The idea is \textit{not} transforming normal vectors together.
Since we already created the meshes with smooth normal vectors, if we transform only positions, then the smoothness via shading will be preserved.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{smooth.png}
\caption[q]{If we take green arrows (not transformed normal vectors) the normals are smooth although actual curve is not smooth.}
\label{fig:tree}
\end{figure}

\subsection{Camera control}
We have two methods moving camera.
One is with keyborad input, another is with mouse moving.
When we give keyboard input, camera moves to 6 direction without rotation.
When we give mouse moving, camera rotates.
These are very basic camera movement, so we want more cinematic movement.
Basic camera model gives us jerky movement, that is, it responses immediately and honestly like normal FPS game when we give input.
But we want more smooth movement, we introduced momentum and time variation to movement.
\begin{itemize}
  \item void CGraphics::M\_MoveCamera(void) moves camera with smooth motion.
\end{itemize}
In case of keyboard, we just give acceleration when camera starts and stops moving.
In case of mouse, we interpolated mouse position with logarithmic term that depends on time.

\subsection{Antialiasing}
Antialiasing is one of the important process in high-quality rendering.
For the geometric fractal, only multi-sampling is ok because it consists of just polygons.
However the textured Mandelbrot set can't be antialiased in that way because it shows very complex structrue in \textit{pixel level}.
Of course all pixel-level rendering doesn't have to be antialiased.
For example, antialiasing the shading won't that helpful because it is inherently smooth.
But Mandelbrot set is very complicatedly structured and the pixels vary greatly, so antialisaing maybe essential.

Unfortunately, we concluded that the only way to perform antialiasing is by super-sampling because there's no way to infer something, but only calculating multiple times.
Thus we tried to perform antialiasing in fragment shader by doing Mandelbrot set membership test multiple times.
We varies testing coordinates slightly within an one pixel size for each sampling, and blend them for final output.

\begin{figure}[H]
\centering
\subfigure[Mandelbrot set without antialiasing]
{
    \label{fig:subfig1}
    \includegraphics[scale=0.2]{noanti.PNG}
}
\subfigure[Mandelbrot set with antialiasing]
{
    \label{fig:subfig1}
    \includegraphics[scale=0.2]{anti.PNG}
}
\caption[1]{Antialiasing comparison}
\end{figure}
We found that rendering quality has been improved but the rendering cost gets very expensive. (fps becomes $<20$)
One of our goal for this project is `real time', so we just discard the antialising.

\section{Gallery}
\begin{figure}[H]
\centering
\subfigure
{
    \label{fig:subfig1}
    \includegraphics[scale=0.1]{o1.PNG}
}
\subfigure
{
    \label{fig:subfig1}
    \includegraphics[scale=0.1]{o2.PNG}
}
\subfigure
{
    \label{fig:subfig1}
    \includegraphics[scale=0.1]{o3.PNG}
}
\subfigure
{
    \label{fig:subfig1}
    \includegraphics[scale=0.1]{o4.PNG}
}
\subfigure
{
    \label{fig:subfig1}
    \includegraphics[scale=0.1]{o5.PNG}
}
\subfigure
{
    \label{fig:subfig1}
    \includegraphics[scale=0.1]{o6.PNG}
}
\caption[1]{Some screenshot captures of program.}
\end{figure}



\section{Discussion}
There are some issues in this project.
\begin{description}[style=nextline]
\item[Smooth Camera Movement]
Unlike movements using a keyboard, mouse movement is a way to obtain the coordinates of the mouse whenever a function is called, rather than pressing button, so it is difficult to determine when the movement of the mouse starts or stops.
Therefore, it is difficult to calculate momentum.
Currently, we only gives interpolation to move the mouse, so it moves smoothly, but it only moves as much as the mouse did because it does not have a momentum.
Adding a term that changes the interpolation through how much the coordinate values have changed can make movement as if it were moving like an object with momentum like keyboard movement.
\item[hihi?]
byebye
\end{description}

\begin{thebibliography}{1}
\bibitem{c1}E. Angel and D. Shreiner, Interactive Computer Graphics: A Top-Down Approach with Shader-Based OpenGL, 6th ed., Addison-Wesley, 2011, p.487 Section 9.8 Recursive Methods and fractals
\bibitem{c2}Graham Sellers; Richard S. Wright, Jr.; Nicholas Hanemel, OpenGL SuperBible, 7th ed., Addison-Wesley, p.683 Rendering Julia Fractals
\bibitem{c3}Rickard Englund, Rendering Methods for 3D Fractals
\bibitem{c4}Fragmentarium,\url{http://syntopia.github.io/Fragmentarium/index.html}
\end{thebibliography}

\end{document}
